<doc><id>unification_(computer_science)</id><concept_name>unification (computer science)</concept_name><wiki>In logic and computer science, unification is an algorithmic process of solving equations between symbolic expressions.
Depending on which expressions (also called terms) are allowed to occur in an equation set (also called unification problem), and which expressions are considered equal, several frameworks of unification are distinguished. If higher-order variables, that is, variables representing functions, are allowed in an expression, the process is called higher-order unification, otherwise first-order unification. If a solution is required to make both sides of each equation literally equal, the process is called syntactic or free unification, otherwise semantic or equational unification, or E-unification, or unification modulo theory.
A solution of a unification problem is denoted as a substitution, that is, a mapping assigning a symbolic value to each variable of the problem's expressions. A unification algorithm should compute for a given problem a complete, and minimal substitution set, that is, a set covering all its solutions, and containing no redundant members. Depending on the framework, a complete and minimal substitution set may have at most one, at most finitely many, or possibly infinitely many members, or may not exist at all.[note 1][1] In some frameworks it is generally impossible to decide whether any solution exists. For first-order syntactical unification, Martelli and Montanari[2] gave an algorithm that reports unsolvability or computes a complete and minimal singleton substitution set containing the so-called most general unifier.
For example, using x,y,z as variables, the singleton equation set { cons(x,cons(x,nil)) = cons(2,y) } is a syntactic first-order unification problem that has the substitution { x &#8614; 2, y &#8614; cons(2,nil) } as its only solution.
The syntactic first-order unification problem { y = cons(2,y) } has no solution over the set of finite terms; however, it has the single solution { y &#8614; cons(2,cons(2,cons(2,...))) } over the set of infinite trees.
The semantic first-order unification problem { a&#8901;x = x&#8901;a } has each substitution of the form { x &#8614; a&#8901;...&#8901;a } as a solution in a semigroup, i.e. if (&#8901;) is considered associative; the same problem, viewed in an abelian group, where  (&#8901;) is considered also commutative, has any substitution at all as a solution.
The singleton set { a = y(x) } is a syntactic second-order unification problem, since y is a function variable.
One solution is { x &#8614; a, y &#8614; (identity function) }; another one is { y &#8614; (constant function mapping each value to a), x &#8614; (any value) }.
</wiki></doc>