<doc><id>software_archaeology</id><concept_name>software archaeology</concept_name><wiki>Software archaeology or software archeology is the study of poorly documented or undocumented legacy software implementations, as part of software maintenance.[1][2] Software archaeology, named by analogy with archaeology,[3] includes the reverse engineering of software modules, and the application of a variety of tools and processes for extracting and understanding program structure and recovering design information.[1][4] Software archaeology may reveal dysfunctional team processes which have produced poorly designed or even unused software modules.[5] The term has been in use for decades,[6] and reflects a fairly natural metaphor: a programmer reading legacy code may feel that he or she is in the same situation as an archaeologist exploring the rubble of an ancient civilization.[7]
A workshop on Software Archaeology at the 2001 OOPSLA (Object-Oriented Programming, Systems, Languages &amp; Applications) conference identified the following software archaeology techniques, some of which are specific to object-oriented programming:[7]
More generally, Andy Hunt and Dave Thomas note the importance of version control, dependency management, text indexing tools such as GLIMPSE and SWISH-E, and "[drawing] a map as you begin exploring."[7]
Like true archaeology, software archaeology involves investigative work to understand the thought processes of one's predecessors.[7] At the OOPSLA workshop, Ward Cunningham suggested a synoptic signature analysis technique which gave an overall "feel" for a program by showing only punctuation, such as semicolons and curly braces.[8] In the same vein, Cunningham has suggested viewing programs in 2 point font in order to understand the overall structure.[9] Another technique identified at the workshop was the use of aspect-oriented programming tools such as AspectJ to systematically introduce tracing code without directly editing the legacy program.[7]
</wiki></doc>